System exploration

mqttBroker "192.168.1.6" : 1883

//Event consoleUpdate: consoleUpdate(X) //robot state update event
//Event tempOk: tempOk(X) //temperature change event
Dispatch  sonarRobot : sonar( DISTANCE )	    //from  sonar on robot      

/*Message from console to robot
//Dispatch explore: explore(X)  
//Dispatch stopExplore: stopExplore(X)
//Dispatch backHome: backHome(X)
//Dispatch continueExplore: continueExplore(X)
//Dispatch backHomeSinceBomb: backHomeSinceBomb(X)
//Dispatch continueExploreAfterPhoto: continueExploreAfterPhoto(X)
 
//Message from robot to console
//Dispatch sendPhoto: sendPhoto(X) 
   
//Message from robot to robot
//Dispatch reachBag: reachBag(X)*/  

Dispatch userCmd  : userCmd( CMD ) //Message from console to robot
Dispatch robotCmd : robotCmd (CMD) //Selfsending robot message 
Dispatch startCmd :	startCmd
Dispatch stopCmd  : stopCmd 

//message try to do a step
Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Dispatch modelChange  : modelChange( TARGET, VALUE )  //force a resource-model change
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )  //sent by the mind TARGET=robot|sonar|roomMap

Dispatch doPlan  : doPlan 
Dispatch planOk  : planOk 
Dispatch planFail  : planFail

Context robotMindCtx        ip [host="localhost" port=8035]   -mqtt
Context robotResourceCtx        ip [host="192.168.1.16" port=8005]   -mqtt

 

QActor robotmind context robotMindCtx { 
["var Curmove     = \"\"  
var IterCounter = 1 
var backHome = true

var finish = false
var Map = \"\"

//VIRTUAL ROBOT
var StepTime   = 500	
var StopTime = 100 
 
var Tback       = 0

var X = 1
var Y = 1

var curX = 0
var curY = 0

var newX = 0 
var newY = 0 

var Dx = 0
var Dy = 0

var plan: List<aima.core.agent.Action>?    = null
var dirtycell: Pair<Int,Int>? = null

"]
	State s0 initial {
		solve (consult ("resourceModel.pl"))
		println("&&&  robotmind STARTED")
		run itunibo.planner.plannerUtil.initAI()
		println("INITIAL MAP") 
		run itunibo.planner.plannerUtil.showMap() 
	} 

	Goto waitForStart
	
	State waitForStart {
	}
	
	Transition t0  whenMsg startCmd  -> startExploration 
				 

	State startExploration {
		println("&&&  exploration STARTED")
		run itunibo.planner.plannerUtil.setGoal(X,Y)
		forward planexecutor -m doPlan:doPlan($X,$Y)
	}
	Transition t1 whenMsg planOk -> nextGoal
				  whenMsg planFail -> checkIfObstacle
				  whenMsg stopCmd -> stopAppl
	
	State stopAppl{
		println("%% robotmind stopped %%")
		forward planexecutor -m stopCmd : stopCmd
		
	}
	Goto waitForStart
	
	State nextGoal {
				
		if "backHome" {
			["
			backHome = false
			X = 0
			Y = 0
			IterCounter++"]
		}
		else {
		["
			backHome = true
			X = IterCounter
			Y = IterCounter
		"]
		}
	}	
	Goto startExploration
	
	
	State checkIfObstacle{
		
		
		println("========== checkIfObstacle ============")
		run itunibo.planner.moveUtils.setObstacleOnCurrentDirection(myself)
		
		run itunibo.planner.plannerUtil.resetGoal(X,Y)	
		//run itunibo.planner.moveUtils.setObstacleOnCurrentDirection(myself)
		
		println("======= RESEAT GOAL ========")
		println(X)
		println(Y)
		
		["plan = itunibo.planner.plannerUtil.doPlan()"]
		
	}
	Goto startExploration if "(plan != null)" else checkNull 
	
	State checkNull{		
		println("========== checkNull ===========")
		
	}
	
	//faccio il goal successivo se il goal in cui voglio andare coincide con ostacolo
	Goto nextGoal if "(!itunibo.planner.plannerUtil.currentGoalApplicable)" else finishChecking 
		
	State finishChecking {
		println("=========== finishChecking =============")
		["dirtycell = itunibo.planner.moveUtils.getDirtyCell()"]
		
		
	}
	
	Goto exloreDirtyCell if "(dirtycell != null)" else endExploration
	
	
	State exloreDirtyCell{
		println("=========== exloreDirtyCell =============")
		["Dx = dirtycell!!.first
		Dy = dirtycell!!.second"]
		
		run itunibo.planner.plannerUtil.setGoal(Dx,Dy)
		
		["plan = itunibo.planner.plannerUtil.doPlan()"]

	}
	
	Goto doExploration if "(plan!=null)" else endExploration
	
	
	State doExploration{
		println("=========== doExploration =============")
		forward planexecutor -m doPlan:doPlan($Dx,$Dy)
	}	
	Transition t2 whenMsg planOk -> finishChecking
				  whenMsg planFail -> setObstacle
				  
	State setObstacle {
		println("=========== setObstacle =============")
		run itunibo.planner.moveUtils.setObstacleOnCurrentDirection(myself)
		
	}
	Goto finishChecking
		
	State endExploration {
		println("=========== endExploration =============")
		run itunibo.planner.plannerUtil.setGoal(0,0)
		forward planexecutor -m doPlan:doPlan(0,0)
	}
	
		
}



//actor who does plans (robot mind has had setgoal  previously)
QActor planexecutor context robotMindCtx {
	
	["
		var Curmove     = \"\"  
		var Map = \"\"
		var Tback = 0
		var StepTime   = 330

    "]
	State s0 initial {} 

	Transition t0  whenMsg doPlan  -> loadPlan 
				
	State loadPlan {
 		printCurrentMessage
 		run itunibo.planner.moveUtils.doPlan( myself ) //moves stored in actor kb
	}
				 	
	Goto doPlan
	
 	State doPlan {}
 	
	Transition t1 whenTime 100  -> doPlan1 		
 		          whenMsg stopCmd -> stopAppl
 		          
 	State stopAppl{
 		forward robotactuator -m robotCmd:robotCmd(h)
 		forward resourcemodel -m modelUpdate:modelUpdate(robot, h)
 		solve(retractall(move(_)))
 	}
 	Goto s0
 	
 	
 	State doPlan1{
 	
		["Map =  itunibo.planner.plannerUtil.getMapOneLine()"]
		forward resourcemodel -m modelUpdate  : modelUpdate( roomMap, $Map )
		run itunibo.planner.plannerUtil.showMap() 
		
		solve( retract( move(M) ) ) 	//consume a move
		ifSolved {  ["Curmove = getCurSol(\"M\").toString()"]  }
		else { ["Curmove=\"nomove\" "]  }
		println(Curmove)

	}  
	
	Goto handlemove if "(Curmove != \"nomove\")" else choose
	
	State choose {
		//if "goalDone" {
		forward robotactuator -m robotCmd : robotCmd(h)
		forward resourcemodel -m modelUpdate  : modelUpdate( robot, h ) 
		forward robotmind -m planOk : planOk 
		//}
		//else {
			//forward robotmind -m goalFailed : goalFailed 
		//}
	}
	
	Goto s0
	
	State handlemove {}
	
	Goto domove if "(Curmove != \"w\")" else attempttogoahead
	
	State domove {
		run itunibo.planner.moveUtils.doPlannedMove(myself, Curmove)
		forward robotactuator -m robotCmd : robotCmd($Curmove)
		forward resourcemodel -m modelUpdate  : modelUpdate( robot, $Curmove ) 
		delay 700
		forward robotactuator -m robotCmd : robotCmd(h)
		forward resourcemodel -m modelUpdate  : modelUpdate( robot, h ) 
	}
	
	Goto doPlan
	
	//roomboundaryplanning.qak
	State attempttogoahead {	
		forward resourcemodel -m modelUpdate  : modelUpdate( robot, w ) 
		run itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime)
	}
	
	Transition t2   whenMsg stepOk   -> stepDone   
					whenMsg stepFail -> stepFailed
					 
 	State stepDone{  
 		forward resourcemodel -m modelUpdate  : modelUpdate( robot, h ) 
 		run itunibo.planner.moveUtils.doPlannedMove(myself, "w")	
 	}
 	
 	Goto doPlan
 	
 	State stepFailed{
 		println("&&&  OBSTACLE FOUND") 
		["var TbackLong = 0L"]		 
 	  	
		//printCurrentMessage		        
 		onMsg( stepFail : stepFail(Obs, Time) ) { 
 			["Tback=(payloadArg(1).toLong().toString().toInt() * 0.80).toInt()
			TbackLong = Tback.toLong()"]
 			println("stepFailed ${payloadArg(1).toString()}")
 		}
  		
 		println(" backToCompensate stepTime=$Tback")
 		forward resourcemodel -m modelUpdate  : modelUpdate( robot, s ) 
 		forward robotactuator -m robotCmd : robotCmd(s)
		delayVar TbackLong
		forward resourcemodel -m modelUpdate  : modelUpdate( robot, h ) 
		forward robotactuator -m robotCmd : robotCmd(h)
		
		solve(retractall(move(_)))
		
		
		forward robotmind -m planFail:planFail
	
	}
	

	Goto s0
	
}




 /*
 * ====================================================================
 * onestepahead robotmind.qak
 * ====================================================================
 */
QActor onestepahead context  robotMindCtx {
[" 
var foundObstacle = false; 
var StepTime = 0L; 
var Duration = 0 ;
var Fail = false;
"]  
	State s0 initial {	   
		["foundObstacle = false "]
	} 
	Transition t0 whenMsg onestep -> doMoveForward
 
	State doMoveForward{	
	 
		onMsg( onestep : onestep( TIME ) ) {
			["StepTime = payloadArg(0).toLong()"]    		
			forward robotactuator -m robotCmd : robotCmd(w)
	 		["startTimer()"] //startTimer is built-in in the actor
	 		
		}      
	}          
	Transition t1 whenTimeVar StepTime  -> endDoMoveForward		
 		          whenMsg stepFail -> stepFail  
 		    
	State endDoMoveForward{
		forward robotactuator -m robotCmd : robotCmd(h)	
		forward planexecutor -m stepOk : stepOk
	}
	Goto s0
	
//	State checkStepFail {
//		onMsg (sonarRobot : sonarRobot(DIS)) { 
//			["Fail = payloadArg(0).toInt() < 10"]
//		}
//	}
//	
//	Goto stepFail if "Fail" else endDoMoveForward
	
	State stepFail{ 
		
		println("===== stepfail =======")
		["Duration=getDuration()"]  //getDuration is built-in in the actor
		printCurrentMessage
		println("onestepahead stepFail Duration=$Duration ")
		
		forward planexecutor -m stepFail : stepFail(obstacle, $Duration)
	}
	Goto s0  
}    


/*
  * --------------------------------------------------------
  * Basic robot: just an actuator of move commands
  * --------------------------------------------------------
  */
QActor robotactuator context robotResourceCtx {
	State s0 initial {
 	 	solve( consult("basicRobotConfig.pl") )
 		solve( robot(R, PORT) )  //R = virtual | realmbot | realnano
  		ifSolved {
     		println( "USING ROBOT : ${getCurSol(\"R\")},  port= ${getCurSol(\"PORT\")} " )
  			run itunibo.robot.robotSupport.create( myself, @R, @PORT, null )
  		}
  		else{ println("no robot") }

   		run itunibo.robot.robotSupport.move( "msg(a)" )
   		
   		delay 700
   		run itunibo.robot.robotSupport.move( "msg(d)" )
   		
   		delay 700
   		run itunibo.robot.robotSupport.move( "msg(h)" )
 
 	}
	Goto waitCmd

	State waitCmd{  } //robotCmd comes from a console OUTSIDE this (sub)system
	Transition t0  whenMsg   robotCmd  -> handleRobotCmd

	State handleRobotCmd{ //does not handle alarms
		printCurrentMessage
		onMsg( robotCmd : robotCmd( MOVE ) ) { //MOVE = w | a | s | d | h
			run itunibo.robot.robotSupport.move( "msg(${payloadArg(0)})" )
		}
 	}
	Goto waitCmd
}


 /*
  * --------------------------------------------------------
  * Resource model: robot state as a coap resource accessile by Restful protocol
  * --------------------------------------------------------
  */
QActor resourcemodel context robotMindCtx{



	State s0 initial {
		solve( consult("sysRules.pl")	 )
		solve( consult("resourceModel.pl")	 )
		solve( showResourceModel )
		run itunibo.coap.modelResourceCoap.create( myself, "resourcemodel" ) //CoAP access
	}
	Goto waitModelChange

	State waitModelChange{ }
	Transition t0 whenMsg modelChange -> changeModel //receive from sonar and frontend
	              whenMsg modelUpdate -> updateModel //forward from robotmind

	State updateModel{
		printCurrentMessage
		onMsg( modelUpdate : modelUpdate(robot,V ) ) {
			run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
			solve( showResourceModel )
		}
		onMsg( modelUpdate : modelUpdate(sonarRobot,V ) ) {
			run itunibo.robot.resourceModelSupport.updateSonarRobotModel( myself, payloadArg(1) )
		}
		onMsg( modelUpdate : modelUpdate(roomMap,V ) ) {  //JULY19
			//println("modelUpdate roomMap")
			run itunibo.robot.resourceModelSupport.updateRoomMapModel( myself, payloadArg(1) )
		}
	}
    Goto  waitModelChange

	State changeModel{
		printCurrentMessage
		//ROBOT MOVE
		onMsg(  modelChange  : modelChange(robot, V ) ) { // V= w | ...
			run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
			solve( showResourceModel )
			//emit local_modelChanged : modelChanged(  robot,  $payloadArg(1))  //for the robotmind
		}
		//SONAR DATA
//		onMsg( modelChange : modelChange( sonarRobot,V ) ) { // V= w | ...
//			run itunibo.robot.resourceModelSupport.updateSonarRobotModel( myself, payloadArg(1) )
//		}

	}
	Goto  waitModelChange
}


 QActor sonarhandler context robotMindCtx{    
 	
 	["var distance = 0"]
 	
  	State init initial{
		println("sonarhandler STARTS ... ")
	}         
	Goto waitForEvents 
	
 	State waitForEvents{  }      
   	Transition t0 whenMsg sonarRobot -> handleSonar 
   				  
 	State handleSonar{
 		printCurrentMessage		
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){
 			["distance = payloadArg(0).toInt()"]
 			
 			forward resourcemodel -m modelChange : modelChange(sonarRobot,$payloadArg(0))
 		}
 	}
 	Goto sonarSaysStop if "(distance < 5)" else waitForEvents
 	 	
 	State sonarSaysStop{
 		
 		forward onestepahead -m stepFail:stepFail
 	}
 	Goto waitForEvents
 	
 }




