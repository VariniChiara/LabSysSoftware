
System ddrsys

//robot state update event
Event consoleUpdate: consoleUpdate(X) 

//temperature change event
Event tempOk: tempOk(X)

Event  sonarRobot   : sonarRobot( DISTANCE )	    //from  sonar on robot      

//Message from console to robot
Dispatch explore: explore(X) 
Dispatch stopExplore: stopExplore(X)
Dispatch backHome: backHome(X)
Dispatch continueExplore: continueExplore(X)
Dispatch backHomeSinceBomb: backHomeSinceBomb(X)
Dispatch continueExploreAfterPhoto: continueExploreAfterPhoto(X)

//Message from robot to console
Dispatch sendPhoto: sendPhoto(X) 

//Message from robot to robot
Dispatch reachBag: reachBag(X)


Dispatch userCmd   : userCmd( CMD ) //Message from console to robot
Dispatch robotCmd  : robotCmd (CMD) //Selfsending robot message


Context ctx ip [host="localhost" port=8090] //-g cyan

QActor console context ctx { 
	
	State s0 initial {
		println("Console intialized")
	} 
	
	Goto sendMsg
	
	State sendMsg {
		forward basicrobot -m robotCmd : robotCmd (w)
		delay 8000
		forward basicrobot -m robotCmd : robotCmd (h)
		
	}
 
}

/* 
QActor robotmind context ctx { 
["var obstacle = false"]
	State s0 initial {
		solve (consult ("ddrsys.pl")) 
		solve (consult ("resourceModel.pl")) 
		println("Robot intialized")
		
	} 
		
	Goto waitForEvents
	  
	State waitForEvents {		} 
	
	Transition t0   whenMsg userCmd  -> handleCmd
					whenMsg robotCmd -> handleCmd
					whenEvent sonarRobot -> handleSonarRobot
 	 
	State handleCmd{  
		printCurrentMessage
		onMsg (userCmd   : userCmd( CMD )){
			solve( action( robot, move($payloadArg(0)) ) ) //change the robot state model
			//forward basicrobot -m  robotCmd  : robotCmd( CMD ) 
			
		}
		onMsg (robotCmd   : robotCmd( CMD )){
			solve( action( robot, move($payloadArg(0)) ) ) //change the robot state model
			//forward basicrobot -m  robotCmd  : robotCmd( CMD )
		}
	}
	
	Goto waitForEvents
	
	State handleSonarRobot{
 		printCurrentMessage
 		onMsg ( sonarRobot : sonarRobot(DISTANCE) ){
			["obstacle = Integer.parseInt( payloadArg(0) ) < 10 "]
 		} 	 
 	}
 	
	Goto handeObstacle  if "obstacle" else waitForEvents 
	
	State handeObstacle{		
		println("handleObstacle: going backward")  
 		forward robotmind -m robotCmd : robotCmd( s ) 		
 			//UPDATE the model : supported action
 			//run itunibo.robot.resourceModelSupport.updateModel( myself, "s" )
 		delay 300
 		println("handeObstacle: stopping")  
	    forward robotmind -m robotCmd : robotCmd( h )
 			//UPDATE the model : supported action
 			//run itunibo.robot.resourceModelSupport.updateModel( myself, "h" )
  	}
  	
	Goto waitForEvents

}


 /*
  * --------------------------------------------------------
  * Basic robot: just an actuator of move commands
  * --------------------------------------------------------
  */ 
  QActor basicrobot context ctx {	 
	State s0 initial {  
		["  
//CREATE A PIPE for the sonar-data stream
val filter = itunibo.robot.sonaractorfilter( \"sonaractorfilter\" , myself  ) 
val logger = itunibo.robot.Logger(\"logFiltered\")
filter.subscribe(logger)  
"] 		
 			 
   		solve( consult("basicRobotConfig.pl") )   
 		solve( robot(R, PORT) )  //R = virtual | realmbot | realnano
  		ifSolved { 
     		println( "USING ROBOT : ${getCurSol(\"R\")},  port= ${getCurSol(\"PORT\")} " )
  			run itunibo.robot.robotSupport.create( myself, @R, @PORT, filter )
  		} 
  		else{ println("no robot") }
    		
   		run itunibo.robot.robotSupport.move( "msg(a)" )
   		delay 700
   		run itunibo.robot.robotSupport.move( "msg(d)" )
   		delay 700
   		run itunibo.robot.robotSupport.move( "msg(h)" )
 	}  
	Goto waitCmd   
 	 
	State waitCmd{  } //robotCmd comes from a console OUTSIDE this (sub)system
	Transition t0  whenMsg   robotCmd  -> handleRobotCmd
	
	State handleRobotCmd{ //does not handle alarms 
		printCurrentMessage 
		onMsg( robotCmd : robotCmd( MOVE ) ) { //MOVE = w | a | s | d | h
			run itunibo.robot.robotSupport.move( "msg(${payloadArg(0)})" ) 
		}	
 	}   
	Goto waitCmd 
}  
 
